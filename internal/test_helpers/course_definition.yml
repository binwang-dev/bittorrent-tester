# Used in your course's URL: https://app.codecrafters.io/courses/<slug>
# Example: "redis"
slug: "bittorrent"

# The name of your course. This will be displayed in the course catalog, and on other course pages.
# Example: "Build your own Redis"
name: "Build your own BitTorrent"

# A short name for your course, this'll be used in copy like emails. 
# Example: "Redis"
short_name: "BitTorrent"

# The release status for your course. 
#
# - alpha: Only visible to yourself and CodeCrafters staff. 
# - beta: Visible to all CodeCrafters users, but with a "beta" label.
# - live: Visible to all CodeCrafters users, no label.
# 
# Allowed values: "alpha", "beta", "live"
release_status: "alpha"

# This is shown on the course overview page. Markdown supported, recommended length ~30 words.
# 
# Recommended format: 
# 
# > In this challenge, you'll build ABC that's capable of D, E, F and G. Along the way, we'll learn about X, Y, Z and more.
# 
# Example:
# 
# > In this challenge, you'll build a toy Redis clone that's capable of handling basic commands like PING, GET
# > and SET. Along the way, we'll learn about event loops, the Redis Protocol and more.
description_md: |
  In this challenge, you’ll build a BitTorrent client that's capable of parsing a .torrent file and downloading a file from a peer.

  Along the way, we’ll learn about how torrent files are structured, HTTP trackers, BitTorrent’s Peer Protocol, pipelining and more.

# This is shown on the catalog. Plaintext only, recommended length ~10 words.
# 
# Recommended format: 
# 
# > Learn about X, Y, Z and more
# 
# Example: 
#
# > Learn about TCP servers, the Redis protocol and more
# 
# **TODO**: Remove _md suffix since markdown isn't supported
short_description_md: |
  Learn about .torrent files, the BitTorrent Peer Protocol and more

# The percentage of users who complete your course. We'll calculate this automatically in the future, safe to ignore for now.
completion_percentage: 15

# The languages that your course supports.
languages:
  - slug: "go"
  - slug: "python"
  - slug: "rust"

marketing:
  # Shown in the catalog. 
  # 
  # Recommended guidelines:
  # 
  # - "easy": < 2h of work for an experienced developer
  # - "medium": > 6h of work for an experienced developer
  # - "hard": > 6h of work for an experienced developer
  #
  # Allowed values: "easy", "medium", "hard"
  difficulty: medium

  # This is shown as an example when users suggest extensions to your course.
  # Example: "Persistence" (from the Redis challenge)
  sample_extension_idea_title: "Multiple Peers"

  # This is shown as an example when users suggest extensions to your course.
  # Example: "A Redis server that can read and write .rdb files" (from the Redis challenge)
  sample_extension_idea_description: "A bittorrent client that can download a file by combining pieces from multiple peers"

  # These are some default testimonials that you can use. Feel free to switch these out with your own.
  testimonials:
    - author_name: "Ananthalakshmi Sankar"
      author_description: "Automation Engineer at Apple"
      author_avatar: "https://codecrafters.io/images/external/testimonials/oxta.jpeg"
      link: "https://github.com/anu294"
      text: "There are few sites I like as much that have a step by step guide. The real-time feedback is so good, it's creepy!"

    - author_name: "Patrick Burris"
      author_description: "Senior Software Developer, CenturyLink"
      author_avatar: "https://codecrafters.io/images/external/testimonials/patrick-burris.jpeg"
      link: "https://github.com/Jumballaya"
      text: |
        I think the instant feedback right there in the git push is really cool.
        Didn't even know that was possible!

stages:
  - slug: "bencode-string" # A identifier for this stage, needs to be unique within a course.

    # The name of the stage. This is shown in the course catalog, and on other course pages.
    name: "Decode bencoded strings"

    # The difficulty of this stage. 
    # 
    # Recommended guidelines, based on how long the stage will take an experienced developer to complete:
    # 
    # - Very Easy (< 5 minutes) 
    # - Easy (5-10 minutes) 
    # - Medium (30m-1h) 
    # - Hard (> 1h)
    # 
    # Allowed values: "very_easy", "easy", "medium", "hard"
    difficulty: very_easy

    # The instructions for your stage. Markdown supported. Shown on the course page.
    description_md: |
        [Bencode](https://en.wikipedia.org/wiki/Bencode) (pronounced *Bee-encode*) is a serialization format used in [the BitTorrent protocol](https://www.bittorrent.org/beps/bep_0003.html). It is used in torrent files and in communication between trackers and peers.

        Bencode supports four data types: 
        - strings
        - integers
        - arrays
        - dictionaries

        In this stage, we'll focus on decoding strings.

        Strings are encoded as `<length>:<contents>`. For example, the string `"hello"` is encoded as `"5:hello"`.

        Here’s how the tester will execute your program:

        ```
        $ ./your_bittorrent.sh decode 5:hello
        "hello"
        ```
    # A description of this stage that is used on the course overview page and other marketing material. Markdown supported.
    marketing_md: |
        [Bencode](https://en.wikipedia.org/wiki/Bencode) is a binary serialization format used in BitTorrent protocol. In this stage, you’ll decode a bencoded string.

  - slug: "bencode-int"
    name: "Decode bencoded integers"
    difficulty: easy
    description_md: |
        In this stage, you’ll decode a bencoded integer value. 

        Integers are encoded as `i<number>e`. For example, `52` is encoded as `i52e` and `-52` is encoded as `i-52e`.

        You're encouraged to use a library to decode bencoded content, but you can create your own parser too.
        {{#lang_is_go}}
        For Go, the recommended library is [bencode-go](https://github.com/jackpal/bencode-go).
        {{/lang_is_go}}
        {{#lang_is_python}}
        For Python, the recommended library is [bencode.py](https://pypi.org/project/bencode.py/)
        {{/lang_is_python}}

        Here’s how the tester will execute your program:

        ```
        $ ./your_bittorrent.sh decode i52e
        52
        ```
    marketing_md: |
        In this stage, you’ll decode a bencoded integer.

  - slug: "bencode-list"
    name: "Decode bencoded lists"
    difficulty: easy
    description_md: |
        In this stage, you’ll decode a bencoded list value.

        A list of values is encoded as **l**&lt;*contents*&gt;**e** . The contents consist of bencoded elements of the list.

        For example, a list consisting of the string "hello" and the number 52 would be encoded as: `l5:helloi52ee`. Note the absence of separators between elements.

        See [Bittorrent Protocol Specification](https://www.bittorrent.org/beps/bep_0003.html#bencoding) for details on bencoding.

        You're encouraged to use a library to decode bencoded content, but you can create your own parser too.
        {{#lang_is_go}}
        For Go, the recommended library is [bencode-go](https://github.com/jackpal/bencode-go).
        {{/lang_is_go}}
        {{#lang_is_python}}
        For Python, the recommended library is [bencode.py](https://pypi.org/project/bencode.py/)
        {{/lang_is_python}}

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh decode l5:helloi52ee
        [“hello”,52]
        ```
    marketing_md: |
        In this stage, you’ll decode a bencoded list.

  - slug: "bencode-dict"
    name: "Decode bencoded dictionaries"
    difficulty: easy
    description_md: |
        In this stage, you’ll decode a bencoded dictionary value.

        A dictionary is encoded as **d**&lt;*contents*&gt;**e** . The elements of the dictionary are encoded with each key immediately followed by its value. All keys must be strings in lexicographical order.

        A dictionary like {“foo”:“bar”, “hello”: 52} would be encoded as: `d3:foo3:bar5:helloi52ee`

        See [Bittorrent Protocol Specification](https://www.bittorrent.org/beps/bep_0003.html#bencoding) for details on bencoding.

        You're encouraged to use a library to decode bencoded content, but you can create your own parser too.
        {{#lang_is_go}}
        For Go, the recommended library is [bencode-go](https://github.com/jackpal/bencode-go)
        {{/lang_is_go}}
        {{#lang_is_python}}
        For Python, the recommended library is [bencode.py](https://pypi.org/project/bencode.py/)
        {{/lang_is_python}}

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh decode d3:foo3:bar5:helloi52ee
        {“foo”:“bar”,“hello”:52}
        ```
    marketing_md: |
        In this stage, you’ll decode a bencoded dictionary.

  - slug: "parse-torrent"
    name: "Parse torrent file"
    difficulty: easy
    description_md: |
        In this stage, you’ll be parsing a torrent file and outputting information about the torrent. A torrent file is a small file containing metadata to facilitate sharing files over the internet. These files are essentially bencoded dictionaries, with the following keys:

        - __announce__: the URL of the tracker
        - __info__: another dictionary with keys: length, name, piece length, pieces

        Having length key present means that torrent consists of a single file. In this case, length indicates size of the file in bytes. You’ll only be working with single file torrents during this challenge as torrents with multiple files contain different keys in their info dictionary.

        See [BitTorrent Protocol Specification](https://www.bittorrent.org/beps/bep_0003.html#metainfo-files) to familiarize yourself with contents of the info dictionary.

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh info test.torrent
        ```
        and here’s the output it expects:
        ```
        Tracker URL: http://linuxtracker.org:2710/00000000000000000000000000000000/announce
        Length: 406847488
        ```
    marketing_md: |
        In this stage, you’ll parse a .torrent file and extract information about the torrent.

  - slug: "infohash"
    name: "Calculate info hash"
    difficulty: easy
    description_md: |
        Info hash is a unique identifier for a torrent file. It’s used to identify a torrent when talking to trackers or peers. It’s not stored in the torrent file but calculated using a cryptographic hash function (SHA-1). This ensures to protect the integrity of the torrent, as adding or removing pieces, or tampering with the length or name of the torrent would change the info hash value.

        In this stage, you’ll be calculating the info hash and printing it in hexadecimal format. 

        Info hash is defined as the 20 byte SHA-1 hash of the bencoded form of the info dictionary in the torrent file (not hash of the whole file, just hash of the bencoded **info** dictionary).

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh info test.torrent
        ```
        and here’s the output it expects:
        ```
        Tracker URL: http://linuxtracker.org:2710/00000000000000000000000000000000/announce
        Length: 406847488
        Info Hash: 6d4795dee70aeb88e03e5336ca7c9fcf0a1e206d
        ```
    marketing_md: |
        In this stage, you’ll calculate a unique identifier for a torrent, known as info hash, used in communication with trackers and peers.

  - slug: "peers"
    name: "Discover peers"
    difficulty: medium
    description_md: |
        Trackers are central servers that maintain information about peers participating in the sharing and downloading of a torrent. BitTorrent protocol supports two types of trackers: [HTTP trackers](https://www.bittorrent.org/beps/bep_0003.html#trackers) and [UDP](https://www.bittorrent.org/beps/bep_0015.html) trackers. Over time, the protocol has evolved to support other mechanisms such as [Distributed Hash Tables (DHT)](http://bittorrent.org/beps/bep_0005.html) and [Peer Exchange (PEX)](http://bittorrent.org/beps/bep_0011.html) to allow peer discovery without relying on central trackers.

        In this stage, you’ll be interacting with an HTTP tracker. You’ll make a GET request to a HTTP tracker to discover peers to download the file from. See [BitTorrent Protocol Specification](https://www.bittorrent.org/beps/bep_0003.html#trackers) for an explanation of keys that need to be included in your GET request. The response will be a bencoded dictionary with two keys: __interval__ and __peers__

        Trackers use a [compact representation](https://www.bittorrent.org/beps/bep_0023.html) of the peer list by default where the value of the **peers** key is a bencoded string rather than a bencoded list.

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh peers test.torrent
        ```
        and here’s the output it expects:
        ```
        188.119.61.177:6881
        71.224.0.29:51414
        62.153.208.98:3652
        ```
    marketing_md: |
        In this stage, you’ll interact with a tracker, a central server that keeps track of peers participating in the sharing of a torrent. You'll make a GET request to a HTTP tracker to discover peers from whom you can download the file.

  - slug: "handshake"
    name: "Peer handshake"
    difficulty: medium
    description_md: |
        In this stage, you’ll establish a TCP connection with a peer and complete a handshake.

        BitTorrent Protocol Specification defines a set of messages that are used to communicate between peers which is called the [peer protocol](https://www.bittorrent.org/beps/bep_0003.html#peer-protocol). The first step after establishing a TCP connection is to complete a handshake. The handshake is a message consisting of the following parts as described in the [peer protocol](https://www.bittorrent.org/beps/bep_0003.html#peer-protocol):
        1. length of the protocol string (BitTorrent protocol) which is 19
        2. the string 'BitTorrent protocol'
        3. eight reserved bytes, which are all set to zero
        4. 20 byte sha1 infohash
        5. 20 byte peer id (something we make up to identify ourselves)

        After we send a handshake to our peer, we should receive a handshake back in the same format. You’ll print the peer id you’ve received during the handshake in hexadecimal format.

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh handshake test.torrent 118.119.61.177:6882
        ```
        and here’s the output it expects:
        ```
        Peer ID: 0102030405060708090a0b0c0d0e0f1011121314
        ```
    marketing_md: |
        In this stage, you’ll establish a TCP connection with a peer and complete a handshake according to [BitTorrent Peer Protocol](https://www.bittorrent.org/beps/bep_0003.html#peer-protocol)

  - slug: "hashes"
    name: "Piece hashes"
    difficulty: easy
    description_md: |
        In this stage, you’ll extract piece length and piece hashes from the torrent file.

        In a torrent, a file is conceptually split into equally-sized parts called **pieces**. A piece is usually 256 KB or 1 MB in size, so a large file could be made up of thousands of pieces. See _piece length_ in [BitTorrent Protocol Specification](https://www.bittorrent.org/beps/bep_0003.html#info-dictionary).

        If you open a torrent file with a text editor, you’ll see a big binary blob. This is a bencoded string containing concatenated SHA-1 hash values of each piece. On public networks, there may be malicious peers that send fake data. These hash values allow us to verify the integrity of each piece that we’ll download. See _pieces_ in [BitTorrent Protocol Specification](https://www.bittorrent.org/beps/bep_0003.html#info-dictionary).

        Your program will print piece length and piece hashes (in hexadecimal format).

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh info test.torrent
        ```
        and here’s the output it expects:
        ```
        Tracker URL: http://linuxtracker.org:2710/00000000000000000000000000000000/announce
        Length: 1048500
        Info Hash: 6d4795dee70aeb88e03e5336ca7c9fcf0a1e206d
        Piece Length: 262144
        Piece Hashes:
        ddf33172599fda84f0a209a3034f79f0b8aa5e22
        795a618a1ee5275e952843b01a56ae4e142752ef
        cdae2ef532d611a46b2cf7b64d578c09b3ac0b6e
        098dadc0c19436f1927ea27b90eb18b1a2820a23
        ```
    marketing_md: |
        In this stage, you’ll extract hash values for each piece of the file. On public networks, there may be malicious peers sending fake data. Piece hashes will help us ensure the integrity of downloaded pieces.

  - slug: "dl-piece"
    name: "Download a piece"
    difficulty: hard
    description_md: |
        In this stage, you’ll download one piece of the file and save it to disk.

        To download a piece of the file from a peer, first you’ll need to establish a TCP connection and complete a handshake with the peer. After that, you’ll be sending and receiving [peer messages](https://www.bittorrent.org/beps/bep_0003.html#peer-messages). Peer messages consist of a message length prefix (4 bytes), message id (1 byte) and a payload (variable size).

        You’ll first receive a `bitfield` message indicating which pieces your peer has. Peers will have all the pieces downloaded during this challenge so you can read and ignore this message for now.

        You’ll send an `interest` message and wait until you receive an `unchoke` message back from your peer. Once you receive an `unchoke` message, you can start sending `request` messages as described in [peer messages](https://www.bittorrent.org/beps/bep_0003.html#peer-messages). To learn more about choking, a mechanism used to control the number of simultaneous downloads, please refer to the [peer protocol](https://www.bittorrent.org/beps/bep_0003.html#peer-protocol).

        To request a piece, you’ll need to break it down into parts called __blocks__. The default recommended block size is 16 kb. So to download a piece that is 128 kb in size, you would need to make 8 requests because our block size is 16 kb.

        Once you receive all the blocks and combine them, you’ll want to check the integrity of the piece. You can compare the piece hash specified in the torrent file with the hash value you calculate for the bytes you’ve downloaded.

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh download_piece -o /tmp/test-piece-0 test.torrent 0
        ```
        and here’s the output it expects:
        ```
        Piece 0 downloaded to /tmp/test-piece-0.
        ```

        **Optional:** To improve download speeds, you can consider pipelining your requests. [BitTorrent Economics Paper](http://bittorrent.org/bittorrentecon.pdf) recommends having 5 recommends pending at once, to avoid a delay between blocks being sent. For example, after requesting the first block, instead of waiting for the block to arrive before requesting the next block, try making 5 requests for blocks at once and every time a block arrives, a new request can be sent.
    marketing_md: |
        In this stage, you'll connect to a peer and download a piece of the file. You'll download the piece in blocks, which you'll later combine and verify using SHA-1, a cryptographic hash value.

  - slug: "dl-file"
    name: "Download the whole file"
    difficulty: hard
    description_md: |
        In this stage, you’ll download the entire file and save it to disk.

        You can start with using a single peer to download all the pieces. You’ll need to download all the pieces, verify their integrity using piece hashes, and combine them to assemble the file.

        Here’s how the tester will execute your program:
        ```
        $ ./your_bittorrent.sh download -o /tmp/test.iso test.torrent
        ```
        and here’s the output it expects:
        ```
        Downloaded test.torrent to /tmp/test.iso.
        ```

        **Optional:** To improve download speeds, you can download from multiple peers at once. You could have a work queue consisting of each piece that needs to be downloaded. Your worker (connection with a peer) could pick a piece from the work queue, attempt to download it, check the integrity, and write the downloaded piece into a buffer. Any failure (network issue, hashes not matching, peer not having the piece etc.) would put the piece back into the work queue to be tried again.
    marketing_md: |
        In this stage, you'll download the entire file. You'll download all the pieces, verify them using SHA-1 and save them to disk.